## 这是学习c++技术栈的记录说明

[主要学习渠道] B站黑马程序员
https://www.bilibili.com/video/BV1et411b73Z/?p=2&vd_source=7111d4cfa9354342c253c06ecdd64e2f

[README] from 2023.6.23


# ===== 部分有趣记录  ====== #

### 1. clion中创建多个子目录或者子工程

https://blog.csdn.net/weixin_40040107/article/details/108167589

### 2. #pragma once 和 #ifndef

https://blog.csdn.net/weixin_41055260/article/details/122994997

2.1 两者的使用方式

    //方式一：
    #ifndef  __SOMEFILE_H__
    #define   __SOMEFILE_H__
    ... ... // 声明、定义语句
    #endif
    
    //方式二：
    #pragmaonce
    ... ... // 声明、定义语句

2.2 两者的特点

    #ifndef 
        受C++语言标准支持, 不仅可以保证同一个文件不会被包含多次, 也能保证内容完全相同的两个文件或者代码片段不会被不小心同时包含. 
    但是, 由于编译器每次都需要打开头文件才能判定是否有重复定义, 因此在编译大型项目时, ifndef会使得编译时间相对较长, 因此一些编译器
    会逐渐开始支持#pragma once的方式. ifndef不受编译器的限制, 

    #pragma once
        一般由编译器提供保证: 同一个文件不会被包含多次. 这里的同一个文件是指物理上的一个文件, 而不是指内容相同的两个文件.
    我们无法对一个头文件中的一段代码做pragma once声明, 而只能针对文件. 其次不必再担心宏名冲突, 大型项目的编译速度也因此可以提高一些.
    对应的缺点是, 如果某个头文件有多份拷贝, 本方法不能保证他们不被重复包含. 这种方式不支持跨平台.


### 3. 耦合和解耦的概念
    耦合是指系统内部的各个部分之间存在相互依赖、相互影响、相互制约的情况. 在物理、工程、计算机等领域, 耦合通常是指两个或者多个系统或者组件之间的相互
    作用关系. 例如, 一个机械系统中的各个部件之间的作用关系、一个电路中各个电子元件之间的相互作用、一个软件系统中各个模块之间的依赖关系等, 都是耦合的
    体现. 在实际应用中, 理解耦合的概念对于设计和优化系统非常重要, 通过调整各个部分之间的耦合程度, 可以改善系统的性能和稳定性, 提高系统的可靠性和安全性.

    耦合是一个系统的各个部分之间彼此关联、互相影响的成都. 当系统内部的各个部分之间的耦合度较高的时候, 其行为会更加紧密地相互关联, 但也更加复杂、难以控制.
    相反, 当各个部分之间的耦合度较低的时候, 行为会更加独立, 也会导致系统的整体性能较差.

    解耦就是减少耦合的过程, 使得模块或者组件之间的依赖尽可能地小, 这样可以使得代码更加模块化、灵活、易于维护和扩展.

    高内聚是另外一个评判软件设计质量的标准, 内聚更为专业的说法是功能内聚, 是对系统中元素职责的相关性和集中度的量度. 如果元素有高度的相关职责, 
    除了这些职责再也没有其他的工作, 那么该元素就有高内聚.

    耦合是模块与模块之间的关系, 最弱的耦合就是通过一个主控模块来协调n个模块进行运作. 
    内聚是指模块内部的功能, 最强的就是功能不能拆分, 也就是原子化. 

### 3. 智能指针、裸指针和引用

    裸指针: 是一个值为内存地址的变量/数据对象, 也就是说指针是一个变量, 只不过存放的是另一个对象的内存地址, 存放另一个对象的地址的操作又叫指向了该对象.
    空指针: nullptr 空指针不指向任何对象指针, 用于初始化指针, 避免出现野指针, 在使用一个指针前可以检查它是否为空
    特殊指针: void *ptr  一种特殊的指针类型, 可以存放各种类型变量的地址. 
    

    裸指针和智能指针的区别:
        1. 变量名 - 地址的助记符, 指针 - 存放内存地址
        2. 定义指针时不赋初值, 该指针叫做野指针. 
        3. 指针指向的对象可以改变, 可以通过赋值-去地址符号改变指针的内容.
        4. 指针类型与指向对象的类型匹配
        5. 裸指针需要手动释放, 否则会造成内存泄露.

    int *a, *b, *c; // 定义了3哥指向int类型变量的指针
    int *a, b, c; // 只有a是指向int类型变量的指针, b c是一般的int型变量

    特殊指针:
        1. void * 指针不能用来访问地址所指向的对象, 即用*取地址对应的内容

    指针和引用:
        1. 引用: 对象的一个别名, 引用访问变量时直接用引用名就可以了, 不需要和指针一样用*
        2. 引用是对指针的简单封装, 底层仍然是指针
        3. 引用在获取地址时, 编译器内部会进行*操作
        4. C++提倡使用引用, 而少用指针
        5. 引用的优势是效率更高. 指针赋值的时候取地址符&会验证地址的有限性, 而引用不需要, 所以引用使用起来的效率会更高
        6. 引用只能绑定在对象上, 不能与字面值或者某个表达式的计算结果绑定在一起
        7. 引用都必须初始化, 所以引用使用之前不需要测试其有效性




    






